\section{Средства синхронизации кода ядра}
Скажем, что \textit{поток команд (thread)}, или \textit{поток} - это любой выполняющийся в системе фрагмент кода. В приложениях, использующих \textit{общую память (shared memory)}, разработчики должны позаботиться о том, чтобы совместно используемые ресурсы были защищены от конкурентного доступа. Совместно используемые ресурсы требуют защиты от конкурентного доступа в связи с тем, что несколько одновременно запущенных потоков команд могут одновременно изменять одни и те же данные. В результате один поток может затереть в памяти изменения, внесенные другим потоком, или обратиться к данным в тот момент, когда они находятся в несогласованном состоянии. Конкурентный доступ к совместно используемым данным часто является причиной нестабильной работы системы. 

\subsection{Критические участки, доступ к системным ресурсам, блокировки и взаимоблокировки}
Рассмотрим более детально, что такое синхронизация, какие причины проблем, возникающих при обеспечении доступа к системным ресурсам и защите данных от конкурентного доступа.
\begin{enumerate}
    \item \textit{Критический участок (critical section)} - это фрагмент кода, в котором выполняется доступ или изменение совместно используемых данных.
    \\\\
    Для предотвращения такого конкурентного доступа к ресурсам из критических
    участков нужно обеспечить неделимое выполнение кода: то есть выполнение критического участка не должно прерываться - будто весь он проходится одной машинной командой.
    \\\\
    Если же критический участок одновременно выполняется несколькими потоками, между ними возникает конфликт из-за доступа к одинаковому ресурсу - называемый \textit{race condition}. Потоки как будто соревнуются за право первым получить доступ к ресурсу.
    \\\\
    Процесс предотвращения небезопасного доступа к ресурсам и устранения конфликтов доступа называется \textit{синхронизацией (synchronization)}.
    \item \textit{Блокировка (lock)} - функция, используемая для блокирования области файла, предотвращая использование этой области другими программами до тех пор, пока область не будет разблокирована. Для разблокирования файла используется \textit{unlock}. 
    \\\\
    Зачем нужны блокировки? Предположим, что у нас есть очередь запросов-команд, то есть можно добавлять новый запрос в конец очереди и извлекать из начала очереди. Такие запросы возникают в различных частях ядра, потому постоянно добавляются, обрабатываются и удаляются. При этом обработка запроса не может быть выполнена одной машинной командой, потому если один поток попытается извлечь из очереди запрос на обработку, а другой в это время уже будет этот запрос обрабатывать - для новопришедшего потока очередь запросов будет находиться в неопределенном состоянии, то есть часть данных может быть затерта. Блокировка реализует механизм, гарантирующий, что в произвольный момент времени только один поток занимается обработкой запроса. Блокировки реализованы на основе атомарных операций (более детально поговорим о них в следующей главе), то есть конфликта из-за доступа при них не возникнет.
    \\\\
    Таким образом, при использовании блокировки алгоритм действий потоков выглядит так:
    \begin{center}
        \begin{tabular}{||c c||} 
            \hline
            Поток 1 & Поток 2 \\ [0.5ex] 
            \hline\hline
            Захват блокировки & Захват блокировки \\ 
            \hline
            Блокировка захвачена & Ожидание разблокировки \\
            \hline
            Доступ к очереди & Ожидание разблокировки \\
            \hline
            Разблокировка & Ожидание разблокировки \\
            \hline
            ... & Блокировка захвачена \\
            \hline
            ... & Доступ к очереди \\
            \hline
            ... & Разблокировка \\[1ex] 
            \hline
        \end{tabular}
    \end{center}
    \\\\
    Важно понимать, что блокировка - это лишь функция, необязательная к использованию, то есть захват блокировки необязателен. 
    \\\\
    В Linux реализовано несколько механизмов блокировок, отличающихся друг между другом в реакции системы на ситуацию, когда блокировка недоступна: например, поток может выполнять постоянную проверку на освобождение блокировки другим потоком или переводить запрос в состояние ожидания до освобождения блокировки.
    \item \textit{Взаимоблокировка (deadlock)} - ситуация, при которой потоку требуется захватить ресурс, но при этом все ресурсы оказались занятыми.
    \\\\
    В таком случае поток переходит в состояние ожидания, пока кто-нибудь не освободит ресурс - но такое невозможно, потмоу что все потоки находятся в состоянии ожидания. В итоге ни один из потоков не может продолжить работу.
     \begin{center}
        \begin{tabular}{||c c||} 
            \hline
            Поток 1 & Поток 2 \\ [0.5ex] 
            \hline\hline
            Захват блокировки А & Захват блокировки В \\ 
            \hline
            Попытка захватить В & Попытка захватить А \\
            \hline
            Ожидание блокировки В & Ожидание блокировки А \\ [1ex]
            \hline
        \end{tabular}
    \end{center}
    \\\\ 
    Различают также \textit{самоблокировку (self-deadlock)} - когда поток пытается захватить блокировку, которую сам захватил ранее, и ожидает разблокировки.
\end{enumerate}

\section{Средства синхронизации ядра}
Перейдем к конкретным средствам, предусмотренным в ядре Linux для устранения конфликтов при доступе к ресурсам и взаимоблокировок.
\begin{enumerate}
    \item \textit{Атомарные операции (atomic operations)} - набор машинных команд, выполняемых как одна цельная машинная команда, то есть без прерывания.
    \\\\
    Атомарные операции всегда выполняются строго последовательно, две такие операции не могут одновременно изменять значения одной переменной.
    \\\\
    В ядре Linux существуют два набора интерфейсов для их выполнения. Для работы с целыми числами (специальный тип данных \textit{atomic\_t}, определенный в \textit{<linux/types.h>}):
    
    \begin{lstlisting}
        <asm-generic/atomic.h>
        
        atomic(64)_t v = ATOMIC_INT(0);
        atomic(64)_set(&v, 4);
        atomic(64)_add(2, &v);
        atomic(64)_inc(&v);
        atomic(64)_read(&v);
        atomic(64)_dec_and_test(&v);
    \end{lstlisting}
    И для работы с отдельными битами (определены в \textit{<asm/bitops.h>}):
    \begin{lstlisting}
        <asm-generic/bitops/*>
    
        unsigned long v = 0;
        set_bit(0, &v);
        set_bit(1, &v);
        clear_bit(1, &v);
        change_bit(0, &v);
        test_and_set_bit(0, &v);
    \end{lstlisting}
    \item \textit{Спин-блокировки} - специальный тип блокировки в ядре Linux, которая может быть захвачена не более чем в одном потоке.
    \\\\
    Если поток попытается захватить спин-блокировку, уже захваченную другим потоком, возникнет состояние конфликта - и первый поток заходит в цикл проверки освобождения требуемой блокировки. Такая циклическая проверка и обеспечивает условие захвата блокировки не более чем одним потоком. 
    \\\\ Важно учитывать, что при возникновении конфликта в таком случае ожидающий поток переходит в замкнутый цикл - и расходует при ожидании процессорное время. Таким образом, не следует удерживать спин-блокировку на большой промежуток времени.
    \\\\
    Спин-блокировки в Linux не рекурсивны. Это означает, что если поток попытается захватить блокировку, которую он уже удерживает, то этот поток войдет в бесконечный цикл, ожидая, пока он сам не освободит блокировку. Но поскольку поток будет периодически проверять, не освободилась ли блокировка, он никогда не сможет ее освободить и возникнет ситуация самоблокировки.
    \\\\
    Спин-блокировки являются зависимыми от аппаратной платформы и реализованы на ассемблере. Зависимый от аппаратной платформы код определен в заголовочном файле \textit{<asm/spinlock.h>}. Сами интерфейсы использования спин-блокировок определены в файле \textit{<linux/spinlock.h>}:
    
    \begin{lstlisting}
        DEFINE_SPINLOCK(mr_lock);
        spin_lock(&mr_lock);
        ...Критический участок...
        spin_unlock(&mr_lock);
    \end{lstlisting}
    Спин-блокировки могут использоваться в обработчиках прерываний, но перед ее захватом необходимо запретить все локальные прерывания (иначе обработчик прерывания прервет выполнение кода ядра, удерживающего блокировку - и снова попытается ее захватить). Для удобства в ядре предусмотрен специальный интерфейс, который позволяет сразу запретить прерывания и захватить блокировку:
    \begin{lstlisting}
    DEFINE_SPINLOCK(mr_lock);
    
    unsigned long flags;
    spin_lock_irqsave(&mr_lock, flags); - сохраняет текущее состояние системы прерываний, запрещает локальные прерывания и захватывает
    ...Критический участок...
    spin_unlock_irqrestore(&mr_lock, flags); - освобождает блокировку и восстанавливает состояние системы
    \end{lstlisting}
    Если же перед захватом прерываниия разрешены, то нет необходимости восстанавливать состояние системы прерывать и можно просто разрешить прерывания при освобождении. Для этого используются следующие команды:
    \begin{lstlisting}
    DEFINE_SPINLOCK(mr_lock);
    
    spin_lock_irq(&mr_lock);
    ...
    spin_unlock_irq(&mr_lock);
    \end{lstlisting}
    \item \textit{RW спин-блокировки (спин-блокировки по чтению-записи)} - спин-блокировки, обеспечивающие отдельные блокировки для операций чтения и записи. 
    \\\\
    Блокировку по чтению могут одновременно захватывать несколько потоков, в которых выполняется считывание данных. Блокировку по записи может захватить только один поток. При этом не допускаются параллельные операции по считыванию данных.
    
    \begin{lstlisting}
    DEFINE_RWLOCK(mr_rwlock);
    
    Reading:
    read_lock(&mr_rwlock);
    ...
    read_unlock(&mr_rwlock);
    
    Writing:
    write_lock(&mr_rwlock);
    ...
    write_unlock(&mr_lock);
    \end{lstlisting}
    \item \textit{Семафоры (semaphore)} - блокировка, переводящая процесс в состояние ожидания.
    \\\\
    При попытке захвата уже захваченного семафора текущая задача помещается в очередь ожидания и замораживается. Процессор переходит к выполнению другой задачи, а как только семафор освобождается, какая-либо задача из очереди ожидания просыпается - и может захватить семафор.
    \\\\ 
    Семафоры подходят для удержания на длительный период времени, потому что задачи переводятся в состояние ожидания. \\При этом не рекомендуется использовать семафоры для реализации блокировок, удерживаемых на короткий период времени, ибо перевод в режим ожилания может по времени превысить период удержания блокировки. \\Семафоры можно захватывать только в контексте процесса, ибо в случае возникновения конфликта поток переводится в состояние ожидания и в контексте прерывания потоки не обрабатываются планировщиком. \\При удержании семафора процесс может переходить в состояние ожидания.\\При захвате семафора нельзя удерживать спин-блокировку, так как процесс может перейти в ожидание до освобождения семафора - а при спин-блокироке нельзя переходить в состояние ожидания.\\Также семафоры нельзя использовать в обработчиках прерывания, ведь они переводят процесс в состояние ожидания.
    \\\\
    Реализация семафоров зависит от аппаратной платформы и определена в файле \textit{<asm/semaphore.h>}. Объекты-семафоры представляются в виде структуры \textit{semaphore}. Статическое определение семафоров:
    
    \begin{lstlisting}
    struct semaphore name;
    sema_init(&name, count);
    \end{lstlisting}
    
    Рассмотрим детальнее использование семафоров:
    \begin{lstlisting}
    down(&s);
    down_interruptible(&s);
    down_trylock(&s);
    up(&s);
    \end{lstlisting}
    Функция \textit{down\_interruptible()} выполняет попытку захватить указанный семафор. Если эта попытка не удалась, то вызывающий ее процесс переводится в состояние ожидания с флагом TASK\_INTERRUPTIBLE, то есть процесс может быть возвращен к выполнению при поступлении сигнала.
    \\\\
    \textit{down()} переводит процесс в состояние ожидания с флагом TASK\_UNINTERRUPTIBLE, то есть процесс не будет отвечать на сигналы. В большинстве случаев это нежелательно, так как процесс, который ожидает освобождения семафора, не будет отвечать на сигналы.
    \\\\
    \textit{down\_interruptible()} же переводит процесс в состояние ожидания с флагом TASK\_INTERRUPTIBLE, потому используется значительно более широко, чем функция down().
    \\\\
    \textit{down\_trylock()} используется для захвата указанного семафора без блокировки. Если семафор уже захвачен, то функция немедленно возвращает ненулевое значение.
    \item \textit{RW семафоры (семафоры для чтения-записи)} аналогично спин-блокировкам предназначены для защиты операций чтения и записи.
    Семафоры для чтения-записи представляются в виде структуры \textit{rw_semaphore}, которая определена в файле \textit{<linux/rwsem.h>}. Статически определенный семафор:
    \begin{lstlisting}
    static DECLARE_RWSEM(name);
    \end{lstlisting}
    Динамически создаваемые семафоры:
    \begin{lstlisting}
    init_rwsem(struct rw_semaphore *sem)
    \end{lstlisting}
    Пример использования:
    \begin{lstlisting}
    static DECLARE_RWSEM(mr_rwsem);
    
    Reading:
    down_read(&mr_rwsem);
    ...
    up_read(&mr_rwsem);
    
    Writing:
    down_write(&mr_rwsem);
    ...
    up_write(&mr_sem);
    \end{lstlisting}
    \item \textit{Мьютекс} - обобщенное название любых типов блокировок, переводящих процесс в состояние ожидания. В современных версиях ядра Linux понятие \textit{“мьютекс”} теперь также означает особый тип блокировки с возможностью перевода процесса в состояние ожидание, с помощью которого реализуется монопольный доступ к некоторому ресурсу. 
    \\\\
    В Linux мьютекс ведет себя так же как семафор со счетчим использований равным единице, но имеет более простой интерфейс. Мьютекс представляется в виде структуры \textit{mutex}:
    
    \begin{lstlisting}
        DEFINE_MUTEX(name);
    
        mutex_init(&mutex);
        
        mutex_lock(&mutex);
        ...
        mutex_unlock(&mutex);
    \end{lstlisting}
    В отличие от семафора, сфера использования мьютексов гораздо уже и более строго определена:
    \\
    В один момент времени мьютекс может удерживать только одна задача.
    \\
    Процесс должен обязательно освободить захваченный мьютекс. Это означает, что мьютекс не пригоден для решения сложных задач синхронизации между ядром и пространством пользователя.
    \\
    Повторные захваты и освобождения мьютексов не разрешаются.
    \\
    Процесс не может завершить свою работу до тех пор, пока он не освободит мьютекс.
    \\
    Мьютекс нельзя захватить в обработчике прерываний или в его нижней половине.
    \\
    Для работы с мьютексами может использоваться только официальное API.
    \item \textit{Условные переменные (completion variable)} - средство синхронизации между двумя задачами в ядре, когда необходимо отправить от одной задачи другой сигнал о событии.
    \\\\
    Условные переменные представляются с помощью структуры  \textit{completion}, которая определена в файле  \textit{<linux/completion.h>}:

    \begin{lstlisting}
        DECLARE_COMPLETION(mr_comp);
        
        init_completion(&var);
        wait_for_completion(&var);
        complete(&var);
    \end{lstlisting}
\end{enumerate}

\subsection{Большая блокировка ядра (BKL, Big Kernel Lock)} 
    По сути является глобальной спин-блокировкой. Во время удержания BKL можно переходить в состояние ожидания. Блокировка автоматически освобождается, когда задача переходит в состояние ожидания, и снова захватывается, когда задача планируется на выполнение. После захвата блокировки BKL запрещается мультипрограммный режим работы ядра.
    \\
    Блокировка BKL рекурсивна. Один процесс может захватывать эту блокировку несколько раз подряд, и это не приведет к самоблокировке, как в случае обычных спин-блокировок.
    \\
    Блокировка BKL может использоваться только в контексте процесса, нельзя захватывать блокировку BKL в контексте прерывания.
    \\
    Использовать блокировку BKL в новом коде не рекомендуется. Важно понимать, что она ведет себя как обычная спин-блокировка, кроме описанных особенностей.
    \\\\
    Интерфейсы блокировки BKL определены в файле \textit{<linux/smp\_lock.h>}
    
    \begin{lstlisting}
        lock_kernel()
        ....
        unlock_kernel()
        
        kernel_locked()
    \end{lstlisting}

\subsection{Последовательная блок\textit{}ировка (sequential lock, seq lock)}
    Новый тип блокировки, который появился в ядрах серии 2.6. Обеспечивает простой механизм для чтения и записи совместно используемых данных, работа основана на счетчике последовательности событий. Перед записью нужных данных захватывается блокировка, и значение счетчика увеличивается на единицу. Перед чтением и после чтения данных выполняется считывание значения счетчика. Если два полученных значения одинаковы, то во время чтения данных новый цикл записи не был начат. Более того, если оба эти значения четные, то к моменту начала чтения цикл записи был уже закончен.
    \\\\
    Интерфейс:
    
    \begin{lstlisting}
        seqlock_t mr_seq_lock = DEFINE_SEQLOCK(mr_seq_lock);

        Writing:
        write_seqlock(&mr_seq_lock);
        ...
        write_sequnlock(&mr_seq_lock);
        
        Reading:
        unsigned long seq;
        do {
            seq = read_seqbegin(&mr_seq_lock);
            ...
        } while (read_seqretry(&mr_seq_lock, seq));
    \end{lstlisting}
    
    Последовательные блокировки позволяют добиться упрощенной и масштабируемой блокировки для очень быстрого доступа к данным в случае, когда применяется много потоков чтения и мало потоков записи. Однако потоки записи получают более высокий приоритет перед потоками чтения. Запрос на блокировку для записи всегда будет удовлетворен в случае, если нет других потоков записи. В отличие от спин-блокировок по чтению записи и семафоров, потоки чтения никак не влияют на захват блокировки для записи. Более того, в потоках, ожидающих разрешения на запись данных, будет постоянно повторяться цикл чтения до тех пор, пока не останется ни одного потока, удерживающего блокировку для записи.
    \\\\
    Таким образом, последовательные блокировки следует использовать, если выполняются почти все следующие условия:
    \\
    - Чтение общих данных происходит множеством потоков.
    \\
    - Есть один или немного потоков для записи.
    \\
    - Необходимо отдать приоритет потокам записи и потоки чтения не должны мешать записи.
    \\
    - Структура общих защищаемых данных достаточно проста или работаем с обычными целами числами, операцию доступа к которым по каким-либо причинам нельзя сделать атомарной.

\subsection{Барьер}
    Барьер — один из примитивов синхронизации. Он создаётся на некоторое количество потоков. Когда первый поток завершает свою работу, то он остаётся ждать у барьера и ждёт, пока не завершат работу остальные потоки. Как только у барьера накапливается ровно столько потоков, на сколько был создан барьер, все потоки, которые ожидают у барьера, продолжают свою работу.
    \\\\
    Основные функции:
    \begin{lstlisting}
        rmb();
        wmb();
        mb();
    \end{lstlisting}
    \\\\
    Функция \textit{rmb() - read memory barrier} позволяет установить в памяти барьер для чтения. Она гарантирует, что при изменении порядка выполнения команд чтения из памяти они не будут переступать через ее вызов. Это значит, что: команды чтения из памяти, выполняемые перед вызовом функции rmb(), не будут переставлены местами с теми командами, которые выполняются после вызова; и те команды чтения, которые выполняются после вызова этой функции, не будут переставлены местами с командами, выполняемыми до вызова.
    \\\\
    Функция \textit{wmb() - write memory barrier} позволяет установить в памяти барьер по записи. Она работает аналогично rmb(), но с операциями записи. При этом гарантируется, что операции записи, которые находятся по разные стороны барьера, никогда не будут переставлены местами друг с другом.
    \\\\
    Функция \textit{mb() - memory barrier} позволяет создать барьер в памяти как для чтения, так и для записи. Никакие команды чтения и записи, которые указаны по разные стороны вызова функции mb(), не будут переставлены местами друг с другом. 

\section{Таймеры и управление временем}
    Одной из важнейших функций ядра является отслеживание хода времени, поскольку довольно большое количество функций запускается по сигналам времени \textit{(time-driven)} - раз в какой-то период (учет относительного времени), планируются на выполнение в какой-то момент времени в будущем (учет абсолютного времени).
    \\\\
    События, требующие учета \textit{относительного времени}, генерируются \textit{системным таймером}. Это аппаратрное устройство, генерирующее аппаратные прерывания с фисированной частотой. В обработчике этого прерывания (прерывания от таймера - timer interrupt) обновляется значение системного времени и выполняются периодические действия. Системный таймер и его прерывания являются основной движущей силой, отвечающий за работу операционной системы Linux.
    \\\\
    \textit{Динамические таймеры (dynamic timers)} - позволяют планировать события, которые должны выполниться один раз после истечения интервала времени. Такие таймеры создаются и аннулируются в ядре динамически по мере необходимости.
    
    \subsection{Учет времени в ядре}
    Чтобы получать информацию о текущей дате и управлять системным временем, ядро должно взаимодействовать с системным аппаратным обеспечением. В это аппаратное обеспечение помимо входит системный таймер, который используется ядром для измерения прошедшего времени. В системном таймере находится кварцевый резонатор, обеспечивающий очень точное значение периода вырабатываемых импульсов. Системный таймер вырабатывает эти импульсы с заранее заданной \textit{частотой импульсов (tick rate)}. Как только истекает период очередного импульса, процессору посылается прерывание от таймера, в результате чего вызывается специальный обработчик прерывания. На основе известной частоты импульсов вычисляется интервал времени между двумя прерываниями - \textit{период следования (tick)}, равный обратному значению частоты и измеряемый в долях секунды.
    \\\\
    Абсолютное значение времени соответствует текущему значению времени суток, ядро в состоянии его отследить, потому что оно обрабатывает прерывания от таймера. Время непрерывной работы системы (system uptime) является относительным и отсчитывается от момента последней перезагрузки системы. Во многих программах требуется знать интервал времени, прошедший между двумя событиями. Проще всего его измерить как разность между двумя значениями времени непрерывной работы системы, считанными в нужные моменты.
    
    \subsection{Переменная jiffies}
    Частота импульсов системного таймера \textit{(tick rate)} программируется при загрузке системы на основании значения статически определенной директивы препроцессора \textit{HZ}. Значение параметра HZ зависит от используемой аппаратной платформы. Более того, для некоторых аппаратных платформ значение параметра HZ отличается даже для разных типов машин. Данный параметр ядра определен в файле \textit{<asm/param.h>}. Частота системного таймера в герцах равна значению параметра HZ, а период таймера равен 1/HZ секунды.
    \\\\
    В глобальной переменной \textit{jiffies} содержится количество импульсов системного таймера, которые были получены со времени загрузки системы. Поскольку каждую секунду возникает HZ прерываний от системного таймера, за секунду значение переменной jiffies увеличивается на HZ. Таким образом, время непрерывной работы системы (uptime) равно \textit{jiffies/HZ} секунд. Однако на практике ядро присваивает переменной jiffies специальное начальное значение, которое вызывает ее частые переполнения, а затем обрабатывает возникшую исключительную ситуацию. Когда запрашивается реальное значение переменной jiffies, это смещение вычитается.
    \\\\
    Переменная jiffies определяется в файле \textit{<linux/jiffies.h>}:
    \begin{lstlisting}
        extern unsigned long volatile jiffies;
    \end{lstlisting}

    \\\\
    В случае 32-разрядного значения переменной jiffies и частоты системного таймера 100 Гц переполнение этой переменной будет происходить примерно каждые 497 дней. В случае 64-разрядного значения переменной jiffies ее переполнение невозможно за время существования чего-либо при любых возможных значениях параметра HZ для любой аппаратной платформы. Такая переменная определяется также в файле \textit{<linux/jiffies.h>}:
    \begin{lstlisting}
        extern u64 jiffies_64;
    \end{lstlisting}
    \\\\
    Переменная jiffies — это просто 32 младших разряда полной 64-разрядной переменной jiffies\_64.
    \\\\
    В ядре предусмотрены четыре макроса для сравнения двух значений счетчика импульсов таймера с учетом возможного переполнения. Все они определены в файле \textit{<linux/jiffies.h>}:
    \begin{lstlisting}
    #define time_after (unknown, known) ((long)(known) - (long)(unknown) < 0)
    #define time_before
    #define time_after_eq (unknown, known) ((long)(unknown) - (long)(known) >= 0)
    #define time_before_eq
    \end{lstlisting}
    
    \subsection{Абсолютное время}
    Текущее значение абсолютного времени (time of day, wall time — время дня) представляется с помощью структуры \textit{timespec} и определяется в файле \textit{kernel/time/timekeeping.c}:
    \begin{lstlisting}
    struct timespec xtime;
    \end{lstlisting}
    \\\\
    Структура данных \textit{timespec} определена в файле \textit{<linux/time.h>}:
    \begin{lstlisting}
    struct timespec {
        __kernel_time_t tv_sec;
        long tv_nsec;
    };
    \end{lstlisting}
    Для обновления значения переменной xtime необходимо захватить последовательную блокировку по записи:
    \begin{lstlisting}
    write_seqlock(&xtime_lock);
    ...
    write_sequnlock(&xtime_lock);
    \end{lstlisting}
    \\\\
    При считывании значения переменной xtime используются функции read\_seqbegin() и read\_seqretry()
    
    \subsection{Таймеры}
    Ранее мы уже говорили про динамические таймеры. Стоит также сказать, что таймеры не являются циклическими. Когда заканчивается интервал времени ожидания, таймер аннулируется. Это одна из причин, почему таймеры называют динамическими. Таймеры постоянно создаются и аннулируются, на количество создаваемых таймеров не накладывается никаких ограничений. Таймеры используются практически во всех частях ядра.
    \\\\
    Таймеры представляются в ядре с помощью структуры \textit{timer\_list}, которая определена в файле \textit{<linux/timer.h>}:
    \begin{lstlisting}
    struct timer_list {
        struct list_head entry; 
        unsigned long expires;
        void (*function)(unsigned long);
        unsigned long data;
        struct tvec_t_base_s *base;
    };
    \end{lstlisting}
    
    \subsection{Обработчик прерываний от таймера}
    Обработчик прерываний от таймера состоит из двух частей: зависимой от аппаратной платформы и независимой от используемого оборудования. Подпрограмма, зависящая от аппаратной платформы, регистрируется в качестве обработчика прерываний от системного таймера и запускается, когда срабатывает системный таймер.
    \\\\
    В большинстве обработчиков выполняются такие действия:
    \\
    - Захватывается блокировка xtime\_lock, которая закрывает доступ к переменной jiffies\_64 и значению текущего времени — переменной xtime — со стороны других процессов.
    \\
    - Считывается или сбрасывается состояние системного таймера, если необходимо.
    \\
    - Периодически записывается новое значение абсолютного времени в CMOS-память часов реального времени.
    \\
    - Вызывается аппаратно-независимая функция таймера tick\_periodic().
    \\\\
    В аппаратно-независимой функции tick\_periodic() выполняется значительно больше действий:
    \\
    - Значение переменной jiffies\_64 увеличивается на единицу.
    \\
    - Для выполняющегося в данный момент процесса обновляется статистка использования системных ресурсов, таких как процессорное время, затраченное на выполнение кода ядра и кода пользовательского приложения.
    \\
    Выполняются обработчики динамических таймеров, для которых истек период
    времени ожидания.
    \\
    - Вызывается функция scheduler\_tick()
    \\
    - Обновляется значение абсолютного времени, которое хранится в переменной xtime.
    \\
    - Вычисляется значение печально известного показателя средней загруженности системы.

    \subsection{Задержка выполнения}
    Часто в коде ядра необходимо на некоторое время задерживать выполнение программы без использования таймеров или привлечения механизма нижних половин. Обычно это необходимо для того, чтобы дать аппаратному обеспечению время на завершение выполнения операции. В ядре предусмотрено несколько способов решения этого. Стоит понимать, что ни один подход не гарантирует, что время задержки будет точно равно указанному значению. Некоторые подходы обеспечивают задержки, очень близкие к точному значению, тем не менее все подходы гарантируют, что время ожидания будет, по крайней мере, не меньше, чем нужно. В некоторых случаях период ожидания получается существенно больше указанного.
    \begin{enumerate}
    \item \textit{Задержка с помощью цикла}
    \\
    Использование \textit{циклов ожидания (busy waiting)} или \textit{холостых циклов (busy waiting)}. В программе нужно запустить холостой бесконечный цикл, пока не будет получено необходимое количество импульсов системного таймера.
    \item \textit{Короткие задержки}
    \\
    Иногда в коде ядра  необходимо создать задержки на очень короткие интервалы времени (короче, чем период системного таймера), причем интервал должен отслеживаться с достаточно высокой точностью. Для этой цели в ядре предусмотрены три функции, обеспечивающие задержки на уровне микро-, нано- и миллисекунд. Они определены в файлах \textit{<linux/delay.h>} и \textit{<asm/delay.h>}:
    \begin{lstlisting}
        void udelay(unsigned long usecs)
        void ndelay(unsigned long nsecs)
        void mdelay(unsigned long msecs)
    \end{lstlisting}
    \item \textit{Функция schedule\_timeout()}
    \\
    Вызов этой функции переводит текущий процесс в состояние ожидания (TASK\_INTERRUPTABLE) как минимум до тех пор, пока не пройдет указанный период времени.
    
    \begin{lstlisting}
        set_current_state(TASK_INTERRUPTIBLE);
        
        schedule_timeout(s * HZ);
    \end{lstlisting}
    Поскольку в функции schedule\_timeout() вызывается планировщик, код, который ее вызывает, должен быть способен перейти в состояние ожидания.
    \end{enumerate}